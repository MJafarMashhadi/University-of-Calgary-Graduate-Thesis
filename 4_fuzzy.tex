% Sample University of Calgary Thesis
% This file contains CHAPTER TWO

\chapter{Data Collection and Fuzzy Test Generation for Auto Pilots}

% 
% points:
% - Need telemtery data from aircraft
% - There is a way in MP to get the data
% - There are 900+ system tests available in MP
% - No system tests in Paparazzi
% - 
% 
% 
% 


\section{Introduction}
A typical model inference pipeline starts with running existing tests in the software under study to collect required data. \cite{Papadopoulos2015} There are several aspects to be considered, what kind of data are needed, how are they going to be collected, and how are they going to be used in model creation which depends on what kind of model we are looking to have. 

Walkinshaw et al. for example, \cite{walkinshaw2016inferring} sought to create state models as extended finite state machines. Their approach requires two collections of ordered events to work, a collection of positive examples which are events generated during a successful execution of the software as well as a set of negative examples. Each event there, is a function call; the log contains the list of functions that were called along with their parameters. 
In \cite{howar2012inferring} the events are high level actions such as `user registered` and `user logged in'. It also seeks to generate state models.
In Synoptic \cite{schneider2010synoptic} the communications in a distributed system is being modeled as an automata and the events are the logs generated by its components.


In this study the goal is to infer a state model of the system under study as a black-box without access to the source code. Therefore I am limited to observing the inputs and outputs of the system. Another piece of information that is often overlooked is time. In this study that is taken into consideration as well. I capture all the inputs and output values of the system in regular intervals. Since they are all numeric, they make a multivariate time series that I use to generate time-aware state models. 


A common theme in almost all model inference algorithms developed in the past two decades is that they use the data collected as the system functions in the wild. They either run existing test cases or instrument and inspect the system being used in production. 
This is to have a diverse collection of data that is also meaningful and representative of the actual system behaviour in common usecases.

Depending on the system under study and the type of data required, this might be an excellent way of collecting the data or might be infeasible in terms of scalability. \cite{mashhadi2019empirical} 
In this study in particular there is an amalgam of both ends of the spectrum. As mentioned earlier, it is done on two auto pilot systems, Micro Pilot and Paparazzi. \cite{hattenberger2014using}
Although they both are highly capable and widely used drone auto pilots, their implementations are quite different which makes data collection phase quite different too.

\section{Data Collection Process}
In this section more details on how data was collected from each system will be presented. 

\subsection{MicroPilot AutoPilot}

\subsubsection{Instrumentation}
Control decisions in this software are made in a 5Hz loop, it means that every 200ms all the sensor inputs are read and based on the current state of the aircraft and the system's goal at the moment (e.g. maintaining a constant speed) decisions will be made and output is generated. Considering this, the best way to capture those data is in the end of this loop. We inserted instrumentation code there to log input and output values at the exact spot where they are updated. 
Please note that although it is more convenient to capture the values in this way, it does not give us any special advantage or insight that breaks the black-box condition. In other words, the exact same data could be collected from the compiled binaries without any access to the internals just with extra steps. Inputs and outputs, after all, are what is available in both black-box and white-box settings.

\subsubsection{Test Scenarios}
MicroPilot has a repository of more than 900 system tests which can be run in a realistic simulator. The auto pilot can be used in SWIL and HWIL modes \cite{melmoth2019true}, software in the loop and hardware in the loop respectively. We used SWIL mode as it provides what we need without any of the overheads associated with HWIL mode. 

\subsection{Paparazzi}

\subsubsection{Instrumentation}
Paparazzi provides a rich and flexible API that can be configured to record several different parameters in flight. The aircraft periodically sends data back to the ground station over a wireless link using a protocol called Paparazzi link. Paparazzi link is built over Ivy, a message bus protocol that uses UDP. In simulations, the modem and wireless communications are no longer needed, instead the auto pilot runs as a separate process and mimics a wireless channel over the local network. (See Figure~\ref{fig:paparazzi_comm_agents})

\begin{figure}
    \centering
    \includegraphics[width=\columnwidth]{4_files/Pprz_communication_agents.jpg}
    \caption{High level overview of communication links architecture in paparazzi \cite{hattenberger2014using}}
    \label{fig:paparazzi_comm_agents}
\end{figure}

Paparazzi comes with a multitude of small tools that could do most of what I needed in terms of instrumentation. There is a remote logger and a log player which are quite close to the instrumentation tool I need, however upon trying them in action, I figured that they cannot record some of the information that I need. Therefore, I developed a custom flight data recorder tool. 

\subsubsection{Test Scenarios}
Unlike MicroPilot that had a quite a number of system tests (in addition to other types of tests such as unit tests which I did not use), Paparazzi comes with only unit tests. As it is an open source software under GPL licence it comes with no warranty and also does not need certain certifications and approvals that commercial systems require, therefore incentives to have such tests are lower. 
Although it is a reliable and widely used auto pilot, it owes that reliability more to its widespread use in action by many researchers and enthusiasts rather than coming from automated tests that verify its behaviour.
In this situation, where many eyes are watching over the code, bugs are discovered and patched quickly. However, to the best of my knowledge they are not recorded as system tests that verify the bugs are properly patched and detect regressions in the future.

To fill the void, I created a tool that can automatically generate valid and meaningful automated system tests for Paparazzi, run them automatically, and integrate with the flight data recorder tool to generate the data set for downstream tasks. It is called Pprz Tester and the source code, version history, project planning data (bugs, enhancements, tasks and issues, etc), and the documentations are available on GitHub at \url{https://github.com/MJafarMashhadi/pprz_tester}. 

In addition to that, I needed to patch some parts of Paparazzi to make the logging and testing more similar to MicroPilot, for example increase telemetry reporting rate from 2Hz to 5Hz. A list of these patches including the reason why that change was necessary or beneficial and the exact lines of code that need to be changed is available in the project wiki at \url{https://github.com/MJafarMashhadi/pprz_tester/wiki/Paparazzi-Patches}.

Aside from the patches, I found some bugs, missing features, missing documentations, and bad smells in the code that needed to be fixed. I contributed new code and documentation to the Paparazzi project to address these issues. The contributions were useful, up to the standards, and welcome in the project; they are included in the latest release\footnote{as of August 1st, 2020} of Paparazzi auto pilot: version 5.16.

\section{The Testing and Data Processing Tool Set}
I implemented the pipeline of generating tests, running them, and aggregating flight logs in an integrated tool with three components, one for each stage. In the following sections I will explain these components and their role in the system. I also explain how event-driven programming paradigm was implemented here both to decrease coupling and to make it more resilient to unexpected or buggy behaviour. It is necessary for two reasons: 1. as a testing tool, it is expected to encounter bugs in software under test 2. the message passing design of Paparazzi architecture as well as supporting multiple aircraft in flight at the same time almost leaves the developer with no choice but an event-driven design.


\subsection{Flight Data Recorder}
Although paparazzi comes with a logging feature in its `server' component (Figure~\ref{fig:paparazzi_comm_agents}), it only logs a subset of required data. Furthermore, the data comes in separate messages with different frequencies; for example speed updates are sent in \verb|AIRSPEED| message once a second, orientation updates and engine rpm are reported in \verb|ATTITUDE| and \verb|ENGINE_STATUS| messages respectively which are dispatched every 200 milliseconds, while servo outputs are only sent once every 5 seconds. All these data need to be aggregated and aligned. Please refer to the Table~\ref{tab:pprz_messages} in \hyperref[appendixa]{Appendix~A} for a full list of messages used.

The most flexible option with the least overhead is to have an independent module that understands Paparazzi link, captures these messages and does data aggregation and logging in real-time. So I created a flight data recorder to collect all the required data from telemetry messages.

In the beginning it starts with listening for \verb|NEW_AIRCRAFT| message to get notified for new aircraft that come online in the simulation. Then it sends a \verb|AIRCRAFTS_REQ| request message to server to get a list of currently online aircraft. The response to both of these messages are processed in the same way: The aircraft unique ID will be checked against the hash table of known aircraft, if it is a new one an ``Aircraft'' instance will be created and added to the hash table. 

Each ``Aircraft'' object in the makes a number of requests back and forth with other components in the system (server, data link, and the auto pilot process) to gather required information about that aircraft, including its flight plan. This class along with ``Aircraft Parameters'' and ``Aircraft Commands'' provide a unified programmatic API for monitoring and controlling the aircraft. 

I implemented observer pattern \cite{gamma1995design} in ``Aircraft Parameters'' to enable other components (such as flight data recorder and automated test executor) to listen for changes in the aircraft state and respond accordingly in a event-driven manner. 
After creation of an ``Aircraft'' object, while it is initializing itself in the background, several observers are created and attached to it. A ``Record Flight'' instance is one of them. It observes new \verb|FLIGHT_PARAM| messages as well as changes in `throttle', 'flight time', and `commands.values' parameters. This class stores and aligns these parameters in a pandas data frame which is stored on disk periodically. The data can be stored in a human-readable CSV file or as a compressed HD5 binary. Some data normalization and unit conversions (such as meters to feet) also happen before saving in order to make the generated data similar to MicroPilot's.

Supplementary UML diagrams are provided in \hyperref[appendixa]{Appendix~A}.


\subsection{Automated Test Executor}
Tests scenarios are defined as subclasses of \verb|PlanBase| class. Each plan needs to override a method that returns an iterable of plan items which should be executed one by one. 
\begin{lstlisting}[language=Python, basicstyle=\linespread{0.1}]
class ExamplePlan(PlanBase):
  def get_items(self, **kwargs):
    block_name = kwargs.pop('block_name')
    circles = int(kwargs.pop('circles'))
    return [items.JumpToBlock(block_name),
      items.WaitForCircles(n_circles=circles)]
\end{lstlisting}
The above plan for example, takes a block name and a number of circles as its parameter and executes the two items in succession. An example of running this plan can be like the command below:
\begin{lstlisting}[language=bash]
$ run_test.py ExampleAircraft ExamplePlan\ 
    -Dblock_name='loiter' -Dcircles=2
\end{lstlisting}
Using this parameters is analogous to test parameterization in mature testing frameworks. It allows similar test plans that are only different in some parameters to be consolidated in one file. Using parameters also improves the reproducibility of test scenarios while improving its flexibility. Test scenarios (plans) do not need to include commands for waiting for aircraft to take off and land, the testing tool automatically wraps it with appropriate initialization code.

The core test plan runner is implemented as an observer class that observes multiple messages and parameters to get notified about changes in the aircraft's state. It iterates over the flight plan items and calls their \verb|match| method to decide whether that item should be executed. Whenever a match is found the item will be executed and the iterator will move to the next test plan item. 

Test plans should be importable from \verb|pprz_tester.generated_plans| module. The structure is simple and clearly defined so that they can easily be handcrafted (like the example above) or generated using test generator component.

The test runner is tailored specifically for paparazzi in several ways. First, it uses standard paparazzi environment variables such as \verb|$PAPARAZZI_HOME|. If it is not set, the user can use \verb|-p /path/to/paprazzi| command line argument to set this value, and if that is not set too, a default value will be used. Second, it can build the auto pilot if \verb|--build| argument is set so the user does not have to build it manually in Paprazzi center. Third, if \verb|--gcs| argument is set, the ground control station window will be opened. It provides a real-time map that visualizes the aircraft path, way point locations, wind direction and velocity, and several other parameters of the aircraft such as their airspeed and altitude. And last, \verb|--no-sim| argument tells tester to not launch the simulator. Its use case can be when a physical auto pilot is being used (HWIL mode, similar to MicroPilot), or when for any reason the user choses to run the simulator manually. 

Test runner can move way points as well. The user can fix any number of way points at specified locations, providing their latitude longitude and altitudes. It can also randomize their location inside a cube. Boudaries of that cube (i.e. east-west, north-south, and floor-ceiling) are customizable through provided command line arguments.

The comprehensive list of command line arguments is included in Table~\ref{tab:test_runner_commandline_args} in \hyperref[appendixa]{Appendix~A}.


\subsection{Automated Test Generator}
This component 
